# REPO.md

## Philosophy

This is an overall philosophy section, not necessarily specific to this project.
Project-specific goals, structure, "definition of done", etc. will go in an
`APP.md` file as specified in `CODEX.md`. That file may override elements of
this `REPO.md` file, but only conservatively. This "philosophy" section should
take precedence in general, but follow an overall philosophy of "most specific"
unless there is ambiguity. Philosophy guides decisions but must not override
explicit requirements in the `APP.md` document. Prefer a boring, obvious
solution over a clever or elegant one unless correctness is compromised.

When principles conflict, prefer:

1. Correctness over simplicity
2. Clarity over configurability
3. Task completion over flexibility

## Template sync policy (governance + management scripts)

This repository may periodically sync a small set of template-managed files
from the canonical template repository `../app-template`. If this is not
available `git@github.com:memotype/twobit-app-template.git` can be checked out
to a temporary directory. Unless the current directory *is* `app-template`,
template files must NOT be modified by Codex.

Goals:
- Keep governance documents and management scripts consistent across app repos.
- Prevent slow drift and "fix it differently in every repo" behavior.

Rules:
- Only files on the explicit TEMPLATE SYNC WHITELIST may be overwritten by a
  template sync.
- All other files are project-owned and must never be overwritten by sync.
- Template sync MUST be performed by a dedicated script (e.g.
  `scripts/sync-template.ps1`) that copies only whitelisted paths.
- Template sync changes MUST be reviewed as a normal diff and committed with a
  message like: `Sync template <ref>`.

TEMPLATE SYNC WHITELIST (core):
- CODEX.md
- REPO.md
- scripts/ensure-npm.cjs
- scripts/typecheck.cjs
- scripts/init-project.ps1
- scripts/sync-deps.ps1
- scripts/sync-template.ps1
- scripts/publish-pages.ps1
- .vscode/settings.json
- privacy_template.md
- codex-prompts.md

Explicit non-sync (project-owned; never overwritten by sync):
- APP.md, README.md, SCRATCH.md, ISSUES.md
- app.json, App.tsx
- package.json, package-lock.json
- eslint.config.cjs, prettier.config.cjs, babel.config.cjs
- tsconfig.json, expo-env.d.ts

Codex behavior:
- Codex MUST NOT edit template-managed files in an app repo except as part of an
  explicit template sync commit.
- Codex MUST NOT suggest submodules for governance distribution. Sync-by-copy is
  the standard mechanism.
- Codex MUST NOT reimplement or locally "fix" template-managed files. If any
  template-managed files in a derived repository are modified in a way that
  introduces *additions* (new logic or content), STOP, generate a diff, and
  issue a warning in chat.

## Git safety warning

Avoid branch-of-branch work unless there is a clear reason. When you need to
merge changes into main, prefer a single branch directly off main. If the
graph is already tangled, do not cherry-pick to main without first tagging
all branch heads and agreeing on a merge plan.

## Release tagging requirement (Android builds)

This requirement applies to app repositories. App repositories must include
an `app.json`. If `app.json` is missing, create it before tagging.

When a git tag is requested or prepared for release, update `app.json` to
include a `versionCode` so Android APK/AAB builds succeed.

If the user requests tagging in an app repo, that request implicitly grants
permission to update `app.json` as needed for `versionCode` compliance.

Rules:
- `app.json` must contain an Android `versionCode` before tagging.
- Increment `versionCode` monotonically for each release tag.

## Languages and Frameworks

- This is an ASCII-only repository. The only exceptions are files generated by
  build scripts such as "SVG->PNG" generation, etc.
- TypeScript will be the primary programming language for the app itself.
- React Native / Expo SDK 54 will be the primary frameworks for app development.
- ASCII-only Markdown will be the primary language for internal documents,
  specifications and miscellaneous files intended for natural language.
- If there is a web component to the app:
  - Static HTML, CSS and client-side-only JavaScript is preferred.
  - No syncing with web services, "AWS Lambda" type systems, SSO, etc., unless
    explicitly required by `APP.md`.
- File formatting:
  - Images will be provided as SVG. Any PNG/JPEG/GIF images should be generated
    from the SVG files. SVG formatting should be formatted for human readability
    (no minimizing).
  - All text files and chat code blocks must be ASCII only. No unicode
    quotation marks, apostrophes, arrow symbols, etc.
  - Line length policy:
    - Target 80-char lines everywhere, including:
      - code
      - Markdown
      - documentation
      - chat code blocks
    - `CODEX.md` and `REPO.md` are read-only for Codex. Line-length lint is
      warning-only for those two files.
    - All other files must treat line-length lint as errors. If a line in a file
      cannot accommodate an 80-character line limit due to code breakage or
      formatting sanity -- if possible -- insert a comment to disable linter
      checks for that line. If no other options exist to resolve or disable
      linter checks for line length, note it in `ISSUES.md` and mark it "low"
      and note that it is a known issue. Markdownlint doesn't support per-line
      disables, the per-line rule doesn't apply to Markdown files.
  - Formatting rules exist to preserve clean diffs and predictable tooling
    behavior, not for stylistic preference.
  - All code and structured data files should pass widely-used, stable linters
    configured in this repository. Prefer conventional, mainstream tooling over
    novel or opinionated alternatives. Linters must enforce only the rules
    explicitly configured here and must not introduce broad, stylistic rewrites
    (especially for Markdown) unless formatting is explicitly delegated to a
    formatter (e.g., Prettier) and scoped via configuration/ignore files.
  - UNIX line endings should be used in all text files that allow it. Any file
    types that require `CRLF` line endings are exempted from this rule. Git
    warnings about `CRLF` conversion should be ignored, and diffs that only
    contain `LF`/`CRLF` differences should also be ignored unless relevant
    to the file type.
  - Codex MUST write files with LF line endings. If a file is encountered with
    `CRLF`, normalize it to `LF` when editing unless the file type explicitly
    requires `CRLF`.


### Package Management Policy

This repository must use **npm as the sole JavaScript package manager**.

Requirements:

- npm is the only supported package manager.
- `package-lock.json` must be generated, committed, and kept in sync.
- Alternative package managers (yarn, pnpm, bun, etc.) must be explicitly
  rejected to avoid dependency drift and build inconsistency.
- The repository must include a `preinstall` script that fails fast with a
  clear error message if any package manager other than npm is used.
- The `package.json` file must declare the expected npm version using the
  `packageManager` field.

Rationale:

This project prioritizes reproducible builds, predictable CI behavior, and
long-term maintainability over package-manager flexibility. Introducing
multiple package managers is considered a source of technical risk and is
intentionally disallowed.

### Dependency Update Protocol

When `package.json` changes, you MUST:

- run `npm install` to update `package-lock.json`
- commit both `package.json` and `package-lock.json` together

CI MUST fail if `package.json` and `package-lock.json` are out of sync.

For app repos, use `scripts/sync-deps.ps1` to align dependencies with the
template and regenerate the lockfile.

Example:

`powershell -File scripts/sync-deps.ps1 -TemplateRef v4.19.1`

Troubleshooting:

- If bundling or linting errors mention `hermes-parser`, ensure it is present
  in `devDependencies` and run `npm install` to refresh the lockfile.

Template release sanity check:

- Before tagging a template release, run `npm run start:clear` and ensure it
  starts cleanly.

### Use of npx

The use of `npx` is permitted only for executing packages that are already
declared in this repository's `dependencies` or `devDependencies`.

Requirements:

- `npx` must not be used to download or execute undeclared packages.
- Any tool required for development, build, linting, or runtime must be
  explicitly listed in `package.json`.
- One-off or ad-hoc tools must be added as dependencies rather than invoked
  via `npx @latest` or similar patterns.

Rationale:

Unconstrained use of `npx` undermines reproducible builds and creates
inconsistencies between developer environments and CI. This project favors
explicit dependencies and predictable behavior over convenience shortcuts.

### Line length and structural clarity

All source files MUST adhere to an 80-character line limit.

To reduce wrap churn and improve readability:
- Prefer named constants over inline literals.
- Prefer small helper functions over deeply nested or compound expressions.
- Decompose complex logic into intermediate values with meaningful names.

Long lines are considered a design smell, not a formatting problem. The correct
response to an overlong line is usually to introduce structure, not to compress
syntax.

This rule applies uniformly to imports, expressions, strings, JSX/TSX, and
configuration files.

### Source File Extensions and Module Conventions

This repository follows strict conventions for source file extensions.
These rules exist to prevent toolchain breakage, ambiguous module
resolution, and accidental mixing of runtime environments.

### TypeScript and React Source Files

- `.tsx` MUST be used for any TypeScript file that contains JSX.
  - This includes React components, screens, layouts, and any function
    that returns JSX.
  - JSX in `.ts` files is forbidden.

- `.ts` MUST be used for TypeScript files that do NOT contain JSX.
  - Examples include utilities, pure logic, data models, state helpers,
    and non-visual hooks.

Rationale:
Separating `.ts` and `.tsx` enforces clarity between UI-rendering code
and non-UI logic, improves editor tooling behavior, and avoids accidental
JSX parsing issues.

### Node.js Tooling and Configuration Files

- `.cjs` MUST be used for Node.js configuration and tooling files that
  rely on CommonJS semantics.
- These files run in Node.js and are NOT part of the application bundle.

Common examples include (but are not limited to):
- `metro.config.cjs`
- `babel.config.cjs`
- `eslint.config.cjs`
- `prettier.config.cjs`
- scripts under `scripts/` that are executed via Node

Rules:
- Codex MUST NOT convert `.cjs` files to `.ts`, `.js`, or `.mjs`.
- Codex MUST NOT rewrite `require()` / `module.exports` syntax into
  `import` / `export` in `.cjs` files.
- `.cjs` files MUST NOT import application runtime code.

Rationale:
React Native / Expo tooling executes in Node.js and often requires
CommonJS. Changing module formats here frequently breaks Metro,
Babel, Jest, or ESLint in non-obvious ways.

## Coding philosophy

### Module System Separation

- Application runtime code MUST use ES module syntax (`import` / `export`)
  and TypeScript (`.ts` / `.tsx`).
- Node.js tooling MUST remain isolated to `.cjs` files unless explicitly
  documented otherwise.

Mixing runtime and tooling concerns in the same file is forbidden.

### Source layout

All product code lives under `src/`. `App.tsx` wires modules together.

#### Preferred module structure
- `src/features/<featureName>/`
  - `index.ts` (public exports)
  - `types.ts`
  - `state.ts` (reducers/store glue if applicable)
  - `logic/` (pure functions, no React)
  - `ui/` (React components)
  - `hooks/` (React hooks, gesture/animation glue)
- `src/ui/` for shared UI components (not feature-specific)
- `src/lib/` for generic utilities (pure)
- `src/assets/` for static assets (or generated outputs)

#### Import rules
- Features MUST NOT import from each other's internal files directly.
  - Import only from `src/features/<featureName>/index.ts`.
- Shared code goes in `src/lib` or `src/ui`, not copied between features.

#### Refactor trigger
- If a feature implementation would add significant logic to `App.tsx`,
  Codex MUST instead create a feature module under `src/features/<featureName>/`
  and import it from `App.tsx`.
- New features MUST be created under `src/features/<featureName>/`.
- Exception: purely generic, reusable UI goes in `src/ui/` and purely generic
  logic goes in `src/lib/`.

### bash shell scripting standard

`bash` is the standard shell scripting language for any scripts to be run on
remote Linux hosts, build servers, etc. Shell script variable naming must follow
these rules:

- ALL_CAPS variables are reserved for:
  - environment variables intended to be exported
  - variables that influence external program behavior (e.g. PATH, IFS,
    ANDROID_SDK_ROOT)
  - special shell variables or well-known conventions
- Internal, script-local variables MUST use lower_case.
  - This includes temporary values, helper variables, flags, paths used only
    within the script, and loop variables.
  - Examples: repo_root, builder_user, is_root, tmp_dir
- Do not use ALL_CAPS for internal script logic.
- If a variable is not exported, isn't used by `bash` to control shell behavior
  and not intended to be consumed by child processes, it must not be ALL_CAPS.

If in doubt, default to lower_case for internal variables.

### Structured Data Formats

This repository standardizes on the following data format preferences:

- **YAML** is the preferred format for structured data wherever reasonably
  possible, including:
  - configuration files
  - parameterization data
  - option tables
  - generated metadata intended to be inspected or modified by humans
  - structured data consumed by scripts or application code

- **JSON** should be used only when required by tooling, external APIs, or
  libraries that mandate it. JSON is not the default choice for new structured
  data files.

- **Markdown** is used for human-facing documentation and governance artifacts
  (e.g., CODEX.md, REPO.md, APP.md, ISSUES.md).

- **XML** should be avoided unless its full feature set is explicitly required
  such as in the case of SVG files. In cases where XML might otherwise be used
  solely for configuration or parameterization, YAML should be used instead.

Rationale:

YAML provides strong machine readability while remaining significantly more
maintainable for humans than JSON or XML. This project prioritizes clarity,
diff quality, and long-term maintainability of structured data over strict
minimalism or legacy conventions.

## App Philosophy & Product Goals

This app is intended to occupy the space between:

- "low-quality, ad-supported 'free' utility apps", and
- "over-engineered, subscription-based apps with expansive infrastructure."

The goal is to deliver a **calm, respectful, single-purpose utility** that a
user is happy to pay a **one-time ~$2 app store purchase** for.

### Core Principles

1. **Task Completion Over Engagement**
   - The app should help the user complete a specific task as quickly and
     clearly as possible.
   - If a feature does not materially improve task completion, it should not be
     implemented.
   - There is no requirement to maximize session time, retention, or daily
     usage (unless daily usage is required for core functionality, e.g. reminder
     apps).
   - Success is defined by _solving the user's problem_, not keeping them in
     the app.
   - No in-app purchases, upsells, paywalls, or monetization logic unless
     explicitly specified in the project section.
   - "This is a screwdriver. It doesn't have 12 speeds or sing your favorite
     song, it just drives screws. But this screwdriver will last a lifetime."

2. **Deterministic, Explainable Behavior**
   - Outputs should be based on transparent, deterministic logic.
   - Where assumptions are made, they should be reasonable, documented, and
     visible to the user when appropriate.
   - Avoid "black box" behavior or unexplained results.

3. **Respect for the User**
   - No advertisements.
   - No tracking, profiling, or behavioral analytics.
   - No accounts, logins, or unnecessary permissions.
   - No dark patterns, nags, or artificial limitations.

4. **Offline-First and Durable**
   - The app should function fully offline unless explicitly stated otherwise.
   - Avoid reliance on external services, APIs, or infrastructure.
   - Prefer solutions that will continue to work unchanged for many years.

5. **Opinionated but Adjustable Defaults**
   - Provide sensible defaults that reduce cognitive load.
   - Allow advanced users to override assumptions when appropriate.
   - Prefer clarity and correctness over configurability for its own sake.

6. **Edge-Case Awareness**
   - Handle common real-world edge cases gracefully.
   - Avoid "happy-path-only" logic typical of free, ad-supported utilities.
   - When trade-offs exist, prefer correctness and fairness over simplicity.

7. **Minimal Surface Area**
   - Keep the UI small, calm, and focused.
   - Avoid unnecessary screens, flows, or features.
   - Each screen should justify its existence.

### Non-Goals

- This app is **not** intended to:
  - be a social platform
  - require ongoing content updates
  - use machine learning or probabilistic models
  - justify a subscription model
  - optimize for virality or engagement metrics

The value proposition is simple:

> _A small, honest tool that does one job well, respects the user, and feels
> worth paying for once._
